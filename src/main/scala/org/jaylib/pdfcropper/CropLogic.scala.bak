package org.jaylib.pdfcropper

import java.awt.image.BufferedImage
import java.io.File
import Utils.usingTempFile

/**
 * Contains the settings and general actions of the Cropper.
 */
abstract class CropLogic extends SettingsAsUserPrefs {

  /** The current PDF file */
  private[this] var currentFile = new File(".")
  /** Total number of pages in the PDF file */
  protected var numPages = 1
  /** The currently selected page number */
  private[this] var selectedPageNo = 1
  /** the currently set CropBox */
  private[this] val currentCropBoxes = Array(CropBox(0, 0, 300, 300), CropBox(0, 0, 300, 300))
  /** for undo action: save the old value (one undo step) */
  private[this] val oldCrop = Array(CropBox(0, 0, 300, 300), CropBox(0, 0, 300, 300))
  protected def updatePages {
    initCropBox(cropBox)
  }

  private def setFile(newFile: File) {
    currentFile = newFile
    initDir.set(file.getParent)
    numPages = EditPdf.getPageNumbers(file)
    initPage
    initCropBox(EditPdf.getCropBox(file, pageNo))
  }
  def file = currentFile
  /**
   * Sets the current file - used when loading or reloading a file.
   */
  def file_=(newFile: File) { setFile(newFile) }

  def reload = { setFile(currentFile) }

  def pageNo = selectedPageNo
  protected def pageNo_=(newPageNo: Int) {
    selectedPageNo = newPageNo
    updateImage
  }
  /**
   * Crops the current file.
   * @param splitNum: if 1 => no splitting done, >1: each page is split into splitNum parts
   */
  def exportFile(splitNum: Int) = EditPdf.export(file, cropBoxes(false), leaveCover,
    new EditPdf.SplitSettings(parts = splitNum, buffer = pagesBuffer, rotate = if (splitNum == 1) 0 else rotateSplitPages))
  /**
   * Crops the current page.
   * @param splitNum: if 1 => no splitting done, >1: each page is split into splitNum parts
   */
  //def cropCurrentPage(splitNum: Int) = exportToFile(file, pageNo, splitNum)

  private[this] def cropBoxIndex = {
    if (twoPages && ((selectedPageNo & 1) == 1)) 1 else 0
  }
  private[this] def otherCropBoxIndex = {
    if ((selectedPageNo & 1) == 1) 0 else 1
  }

  def cropBox: CropBox = currentCropBoxes(cropBoxIndex)

  private[this] def upateCropBoxY(index: Int, cropBox: CropBox) {
    val copy = currentCropBoxes(index)
    currentCropBoxes(index) = CropBox(copy.x0, cropBox.y0, copy.x1, cropBox.y1)
  }
  /**
   * Updates the CropBox.
   */
  def cropBox_=(newCropBox: CropBox) = {
    oldCrop(cropBoxIndex) = cropBox
    currentCropBoxes(cropBoxIndex) = newCropBox
    if (twoPages && sameHeight)
      upateCropBoxY(otherCropBoxIndex, newCropBox)
    updateImage
  }
  def updateCropBoxes(cropBoxes: Array[CropBox]) = {
    currentCropBoxes.copyToArray(oldCrop)
    cropBoxes.copyToArray(currentCropBoxes)
    if (sameHeight && currentCropBoxes(0).height != currentCropBoxes(1).height) {
      if (currentCropBoxes(0).height < currentCropBoxes(1).height)
        upateCropBoxY(0, currentCropBoxes(1))
      else
        upateCropBoxY(1, currentCropBoxes(0))
    }
    updateImage
  }
  protected def initCropBox(crop: CropBox) {
    updateCropBoxes(Array.fill(currentCropBoxes.length)(crop))
  }

  /**
   * Revets the cropBox to the previous value (undo).
   */
  def revertCrop { cropBox = oldCrop(cropBoxIndex) }

  def incPage(inc: Int) { pageNo = pageNo + inc }
  def firstPage { pageNo = 1 }
  def lastPage { pageNo = numPages }
  def initPage { pageNo = ((numPages + 1) / 2) }

  private[this] def cropBoxes(singlePage: Boolean) = if (twoPages && !singlePage) currentCropBoxes.toList.reverse else List(cropBox)

  def autoCrop(chkPages: Int = autoPagesNumber.get) {
    val first = Math.max(1, pageNo - (chkPages - 1) / 2)
    val last = Math.min(numPages, first + chkPages)
    val count = last - first + 1
    // calculate the crops for several pages using in parallel - using the "par"
    val crops = for (page <- (first to last).par)
      yield EditPdf.calcShiftedCrop(file, GsImageLoader.findAutoBox(GsImageLoader.load(file, page)), page)

    // set the new crop box using the minimum/maximum values of the collected crops
    if (!crops.isEmpty) {
      if (twoPages) {
        // build streams of crops - the first containing the odd (first, third, etc.) elements - the second the even
        def part(i: Int): Stream[CropBox] = crops(i) #:: part(i + 2)
        val boxes = Array(
          part(0).take((count + 1) / 2),
          part(1).take(count / 2)).map(crops2 =>
            CropBox(crops2.map(_.x0).min, crops2.map(_.y0).min, crops2.map(_.x1).max, crops2.map(_.y1).max))

        updateCropBoxes(if ((first & 1) == 0) boxes else boxes.reverse)
      }
      else {
        cropBox = CropBox(crops.map(_.x0).min, crops.map(_.y0).min, crops.map(_.x1).max, crops.map(_.y1).max)
      }
    }
  }

  protected def updateImage {
    onUpdateImage(GsImageLoader.load(file, pageNo, cropBox))

  }

  def exec(f: File) {
    import scala.sys.process._
    if (callExec)
      ("cmd /c \"" + f.getAbsolutePath + "\"").run
  }

  protected def onUpdateImage(image: BufferedImage)

  def configOptions()
}